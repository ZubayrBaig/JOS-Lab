Q1: uintptr_t. Because “value” is a normal C pointer, it holds a virtual address, not a physical address. When we cast that pointer to an integer, we’re just storing that virtual address in an integer type. uintptr_t is the integer type meant to hold virtual addresses. 

Q2: After setup, the page directory has entries from PDX(KERNBASE)=960 up to 1023 filled. These entries map the high virtual addresses starting at 0xF0000000 straight to physical memory, one 4MB chunk per entry. In that same high area, there are also present entries for UVPT, UPAGES, and the kernel stack just below KSTACKTOP (with a guard page left unmapped). The low entries like 0, 1, 2 are not present in the final kernel page directory.

Q3: User programs can’t touch kernel memory because the page tables mark all kernel pages with PTE_U = 0 (not accessible from user mode). The CPU checks this on every memory access in user mode and blocks it in hardware. Some special regions that users may read (like UPAGES) are mapped with PTE_U = 1 but PTE_W = 0, so they’re read-only to users. The kernel also turns on CR0.WP so even kernel-mode respects read-only pages.

Q4: 256 MB. The kernel direct maps all physical memory into the virtual window starting at KERNBASE = 0xF0000000. That window’s size is 2^32 − 0xF0000000 = 0x10000000 = 256 MB, so that’s the most physical RAM this setup can cover.

Q5: It's around 780 KB of overhead when we are backing up the whole 256 MB of RAM. The biggest chunk is the pages[] array. There’s 1 entry per 4 KB page, so 256 MB is equivalent to 65,536 pages. If a PageInfo is approximately 8 bytes than that's ~512 KB there alone. Then theres page tables for the large kernel direct map at KERNBASE. Each addresses 4 MB so you need 64 of them. 64 × 4 KB = 256 KB. Add the page directory and include a few spare page tables for UPAGES and the kernel stack area. All together: 512 KB + 256 KB + 4 KB + ~8 KB there’s ~780 KB. 

Q6: Right after we flip on paging, the CPU keeps running at a low EIP because the early page tables include an identity mapping of the first few megabytes. The code at ~1 MB is still visible at the same virtual address, so execution doesn’t instantly jump anywhere. We only transition to a high EIP when the boot code does an explicit jump/call into the kernel’s high virtual address. That jump is safe because those same page tables also map the kernel at its high addresses. This two-mapping setup is what lets us keep running at a low EIP for a moment after enabling paging, and then cleanly “move up” with a single jump. We do this so the kernel can live permanently in the upper part of the address space, leaving the lower part free for user processes and giving the kernel a big, simple direct map of physical memory.
